{ pkgs, lib, inputs, config, ... }:
# TODO: Somehow DHCPd isn't working or assigning.
# TODO: Ntpd / openntpd/ chrony
# TODO: Move outside of Zuul host.
let
  wan = "enp1s0";
  lan = [ "enp2s0" "enp3s0" ];
  network = {
    domain = "baillie.id";
    nodes = [
      {
        hostName = "betsy";
        ipAddress = "10.0.1.5";
        ethernetAddress = "28:7f:cf:53:79:6f";
      }
      {
        hostName = "eth.betsy";
        ipAddress = "10.0.1.5";
        ethernetAddress = "f8:75:a4:1c:c0:38";
      }
      {
        hostName = "bebek";
        ipAddress = "10.0.1.6";
        ethernetAddress = "3c:a6:f6:10:98:dc";
      }
    ];
  };
in
{
  imports = [
    inputs.nixos-hardware.nixosModules.pcengines-apu
  ];

  # TODO: Do I care about this being in /etc/hosts? Could just be in Unbound.
  networking.stevenBlackHosts = {
    enable = true;
    blockFakenews = true;
    blockGambling = true;
  };

  ##############################################################
  # TEMP:
  users.users.root.password = lib.mkForce "nixos";
  services.openssh = {
    permitRootLogin = lib.mkForce "yes";
    passwordAuthentication = lib.mkForce true;
  };
  services.getty.autologinUser = lib.mkForce "root";
  ##############################################################

  modules = {
    editors = {
      vim.enable = true;
      default = "vim";
    };

    services = { ssh.enable = true; };

    shell = {
      enable = true;

      git.enable = true;
      zsh.enable = true;
    };
  };

  boot = {
    loader.grub = {
      enable = true;
      version = 2;
      device = "/dev/sda";
    };

    kernelParams = [ "ipv6.disable=1" ];

    kernel.sysctl = {
      # IP forwarding.
      "net.ipv4.conf.all.forwarding" = 1;
      "net.ipv4.ip_forward" = 1;

      # Disable netfilter for bridges.
      # NOTE: means bridge-routed frames do not go through iptables
      # https://bugzilla.redhat.com/show_bug.cgi?id=512206#c0
      "net.bridge.bridge-nf-call-iptables" = 0;
      "net.bridge.bridge-nf-call-arptables" = 0;

      # Increase default/max size of socket rw buffers.
      "net.core.rmem_default" = 31457280;
      "net.core.wmem_default" = 31457280;
      "net.core.rmem_max" = 2147483647;
      "net.core.wmem_max" = 2147483647;
    };
  };

  networking = {
    enableIPv6 = false;
    domain = network.domain;
    search = [ network.domain ];

    bridges = {
      br0.interfaces = lan;
    };

    vlans = {
      # Trusted, free-roam personal devices.
      prv = {
        id = 20;
        interface = "br0";
      };

      # Untrusted, locked-down IoT devices.
      iot = {
        id = 30;
        interface = "br0";
      };
    };

    # The global useDHCP flag is deprecated, therefore explicitly set to false
    # here. Per-interface useDHCP will be mandatory in the future, so this
    # generated config replicates the default behaviour.
    useDHCP = false;
    dhcpcd = {
      extraConfig = ''
        debug
        noipv6rs
        noipv4ll
      '';
    };
    interfaces = {
      ${wan}.useDHCP = true; # IPoE / Dynamic IP.
      enp2s0.useDHCP = false;
      enp3s0.useDHCP = false;

      prv = {
        ipv4.addresses = [{
          address = "10.0.1.1";
          prefixLength = 24;
        }];
      };

      iot = {
        ipv4.addresses = [{
          address = "10.0.254.1";
          prefixLength = 24;
        }];
      };

    };

    # NAT.
    nat = {
      enable = true;
      externalInterface = wan;
      internalInterfaces = lan;
      internalIPs = [ ]
        ++ map (a: "${a.address}/${toString a.prefixLength} allow")
        config.networking.interfaces.prv.ipv4.addresses
        ++ map (a: "${a.address}/${toString a.prefixLength} allow")
        config.networking.interfaces.iot.ipv4.addresses;
    };


    firewall = {
      enable = true;
      allowPing = true;
      trustedInterfaces = lan;
    };
  };

  # Balance the CPU load generated by interrupts across all of the procs.
  services.irqbalance.enable = true;

  services.dhcpd4 = {
    enable = true;
    interfaces = lan;
    machines = network.nodes;
    extraFlags = [ "-d" ];
    extraConfig = ''
      option domain-name-servers 10.0.1.1;
      option subnet-mask 255.255.255.0;

      subnet 10.0.1.0 netmask 255.255.255.0 {
        option domain-name-servers 10.0.1.1;
        option broadcast-address 10.0.1.255;
        option routers 10.0.1.1;
        range 10.0.1.128 10.0.1.254;
      }

      subnet 10.0.254.0 netmask 255.255.255.0 {
        option domain-name-servers 10.0.1.1;
        option broadcast-address 10.0.254.255;
        option routers 10.0.254.1;
        range 10.0.254.128 10.0.254.254;
      }
    '';
  };

  services.unbound = {
    enable = true;
    localControlSocketPath = "/run/unbound/unbound.ctl";
    settings = {
      server =
        let
          # Make the bad hosts list compatible with Unbound.
          badhosts = with pkgs; with inputs; runCommand "badhosts.db" { } ''
            ${gnugrep}/bin/grep '^0\.0\.0\.0' ${bad-hosts}/alternates/fakenews-gambling-porn/hosts | \
            ${gawk}/bin/awk '{print "local-zone: \""$2"\" redirect\nlocal-data: \""$2" A 0.0.0.0\""}' > $out
          '';
        in
        {
          # TODO: use `network.nix` for IPs.
          interface = [ "127.0.0.1" ];
          access-control = [
            "127.0.0.0/8 allow"
          ]
          ++ map (a: "${a.address}/${toString a.prefixLength} allow")
            config.networking.interfaces.prv.ipv4.addresses
          ++ map (a: "${a.address}/${toString a.prefixLength} allow")
            config.networking.interfaces.iot.ipv4.addresses;

          # Ensure privacy of local IP (RFC1918) ranges.
          private-address = [
            "192.168.0.0/16"
            "169.254.0.0/16"
            "172.16.0.0/12"
            "10.0.0.0/8"
            "fd00::/8"
            "fe80::/10"
          ];

          log-queries = true;
          statistics-interval = 0;
          extended-statistics = true;
          statistics-cumulative = true;

          domain-insecure = true;
          private-domain = "baillie.id";
          tls-cert-bundle = "/etc/ssl/certs/ca-certificates.crt";

          # Perform prefetching of close to expired message cache entries. This
          # only applies to domains that have been frequently queried.
          prefetch = true;

          # Ensure kernel buffers are large enough to not lose messages in
          # heavy traffic.
          so-rcvbuf = "4m";
          so-reuseport = true;
          so-sndbuf = "4m";

          hide-identity = true;
          hide-version = true;

          local-zone = map (node: ''"${node.hostName}.${network.domain}." redirect'')
            network.nodes;
          local-data = map (node: ''"${node.hostName}.${network.domain}. A ${node.ipAddress}"'')
            network.nodes;

          include = [ (toString badhosts) ];
        };
      forward-zone = [
        {
          name = ".";
          forward-addr = [
            "8.8.8.8@853#dns.google"
            "1.1.1.1@853#cloudflare-dns.com"
            "8.8.4.4@853#dns.google"
            "1.0.0.1@853#cloudflare-dns.com"
          ];
          forward-ssl-upstream = true;
        }
      ];
      remote-control = {
        control-enable = true;
        control-use-cert = false;
      };
    };
  };

  environment.systemPackages = with pkgs; [
    conntrack-tools
    dig
    ethtool
    tcpdump
    vim
  ];
}
